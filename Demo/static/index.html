<html lang="en">
<head>
  <title>Emotion Patterns in Music Playlists - Demo</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  <style>
    img {
      width: 100px;
      height: 100px;
    }
  </style>
  <script>
    function Song(artist, title) {
      this.artist = artist
      this.title = title
    }

    function argMax(array) {
        return array.map((x, i) => [x, i]).reduce((r, a) => (a[0] > r[0] ? a : r))[1];
    }

    function buildPredictionMatrix() {
      predictions = []

      $('#emotion-table-rows tr').each(function() {
        tds = $(this).find('td')
        predictions.push([
          parseFloat(tds[2].textContent), 
          parseFloat(tds[3].textContent), 
          parseFloat(tds[4].textContent),
          parseFloat(tds[5].textContent)
        ])
      })

      return predictions
    }

    function markOutliers(outliers) {
      idx = 0

      $('#emotion-table-rows tr').each(function() {
        tds = $(this).find('td')
        for(var i = 0; i < outliers.length; i++) {
          if(outliers[i][0] == idx) {
            offset = 2
            elements = []
            for(var j = 0; j < tds.length - 2; j++) {
              if(j == outliers[i][1]) {
                $(tds[offset+j]).css('color', 'red')//#.html('<font color"red">'+parseFloat(tds[j+offset].textContent)+'</font>')
              }
            }
          }
        }
        idx++
      })
    }

    function buildTransitionGraph(transitions) {
      // Nodes
      emonodes = []
      for(var i = 0; i < labels.length; i++) {
        var recurrent =  transitions[i][i] > 0 ?  '\n(' + transitions[i][i] + ')' : ''
        emonodes.push({name:labels[i] + recurrent})
      }

      // Edges
      emoedges = []
      for(var i = 0; i < 4; i++) {
        for(var j = 0; j < 4; j++) {
          if(transitions[i][j] > 0 && i != j)
            emoedges.push({source:i, target:j})
        }
      }
      
      // Data
      var data = {
        nodes: emonodes,
        edges: emoedges
      }

      // Draw the graph

      var w = 450;
      var h = 350;
      var linkDistance=150;

      var colors = d3.scale.category10();

      var svg = d3.select('#graph-container').append("svg").attr({"width":w,"height":h});

      var force = d3.layout.force()
          .nodes(data.nodes)
          .links(data.edges)
          .size([w,h])
          .linkDistance([linkDistance])
          .charge([-500])
          .theta(0.1)
          .gravity(0.05)
          .start(); 

      var edges = svg.selectAll("line")
        .data(data.edges)
        .enter()
        .append("line")
        .attr("id",function(d,i) {return 'edge'+i})
        .attr('marker-end','url(#arrowhead)')
        .style("stroke","#ccc")
        .style("pointer-events", "none");
      
      var nodes = svg.selectAll("circle")
        .data(data.nodes)
        .enter()
        .append("circle")
        .attr({"r":40})
        .style("fill",function(d,i){return colors(i);})
        .call(force.drag)


      var nodelabels = svg.selectAll(".nodelabel") 
         .data(data.nodes)
         .enter()
         .append("text")
         .attr({"x":function(d){return d.x;},
                "y":function(d){return d.y;},
                "class":"nodelabel",
                "stroke":"black"})
         .text(function(d){return d.name;});

      var edgepaths = svg.selectAll(".edgepath")
          .data(data.edges)
          .enter()
          .append('path')
          .attr({'d': function(d) {return 'M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y},
                 'class':'edgepath',
                 'fill-opacity':0,
                 'stroke-opacity':0,
                 'fill':'blue',
                 'stroke':'red',
                 'id':function(d,i) {return 'edgepath'+i}})
          .style("pointer-events", "none");

      var edgelabels = svg.selectAll(".edgelabel")
          .data(data.edges)
          .enter()
          .append('text')
          .style("pointer-events", "none")
          .attr({'class':'edgelabel',
                 'id':function(d,i){return 'edgelabel'+i},
                 'dx':80,
                 'dy':0,
                 'font-size':18});

      edgelabels.append('textPath')
          .attr('xlink:href',function(d,i) {return '#edgepath'+i})
          .style("pointer-events", "none")
          .text(function(d,i){return transitions[d.source.index][d.target.index]});


      svg.append('defs').append('marker')
          .attr({'id':'arrowhead',
                 'viewBox':'-0 -5 10 10',
                 'refX':25,
                 'refY':0,
                 //'markerUnits':'strokeWidth',
                 'orient':'auto',
                 'markerWidth':10,
                 'markerHeight':10,
                 'xoverflow':'visible'})
          .append('svg:path')
              .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
              .attr('fill', '#ccc')
              .attr('stroke','#ccc');

          force.on("tick", function(){

            edges.attr({"x1": function(d){return d.source.x;},
                        "y1": function(d){return d.source.y;},
                        "x2": function(d){return d.target.x;},
                        "y2": function(d){return d.target.y;}
            });

            nodes.attr({"cx":function(d){return d.x;},
                        "cy":function(d){return d.y;}
            });

            nodelabels.attr("x", function(d) { return d.x; }) 
                      .attr("y", function(d) { return d.y; });

            edgepaths.attr('d', function(d) { var path='M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y;
                                               return path});       

            edgelabels.attr('transform',function(d,i){
                if (d.target.x<d.source.x){
                    bbox = this.getBBox();
                    rx = bbox.x+bbox.width/2;
                    ry = bbox.y+bbox.height/2;
                    return 'rotate(180 '+rx+' '+ry+')';
                    }
                else {
                    return 'rotate(0)';
                    }
            });
        });
    }

    // Our "dataset"
    dataset = [
      new Song('Nirvana', 'Smells Like Teen Spirit'),
      new Song('The Beatles', 'Yesterday'),
      new Song('Oasis', 'Wonderwall'),
      new Song('The Clash', 'Should I stay or Should I go'),
      new Song('The Rolling Stones', '(I Can\'t Get No) Satisfaction'),
      new Song('Queen', 'Don\'t Stop Me Now'),
      new Song('Led Zeppelin', 'Stairway to Heaven'),
    ]

    labels = ['Angry',  'Happy', 'Relaxed', 'Sad']
    emotion_img = ['static/img/angry.png', 'static/img/happy.png', 'static/img/relaxed.png', 'static/img/sad.png']
  </script>
</head>
<body>
  
<div id='top-div'  class="container-fluid">
  <h1>Emotion Patterns in Music Playlists</h1>

  <p>
  Music streaming services such as Spotify are revolutionizing the music world, enabling a transition from artist-created bundles of songs (CDs) to user-created playlists. Different logics may be applied in the generation of a playlist: they can contain songs of a similar genre (e.g. “Rock playlist”), fit to a particular occasion (e.g. “New year’s eve party”), to a particular context (e.g. “Gym”), to a particular mood (e.g. “Happy”) and so on.
  </p>

  <p>
  The goal of the project is to unravel the emotion patterns underlying the sequences of songs in a playlist using automatic approaches of Emotion Detection on the lyrics. Emotion Detection is a novel and promising field of study of Natural Language Understanding, which is able to automatically infer what are the emotions expressed in a text.
  </p>

  <p>
  In the context of this project we had to:
  </p>

  <ol>
    <li>Select an appropriate playlist dataset among the ones available on the web</li>
    <li>Collect the lyrics associated to each song through an automatic approach</li>
    <li>Study the state-of-the-art in Emotion Detection</li>
    <li>Extract the emotions present in each song using an Emotion Detection tool</li>
    <li>Analyze the experimental results statistically to unravel emotion patterns in the playlists</li>
  </ol>

  <p>This web application was developed with the purpose of demoing the
  semester project title "Emotion Patterns in Music Playlist", developed by Mario Guerriero
  and Sara Giammusso in collaboration with professor Raphael Troncy and Pasquale Lisena at EURECOM.</p>

  <button id='classify-btn'  type="button" class="btn btn-primary">Classify</button>
  <button id='classify-playlist-btn'  type="button" class="btn btn-success">Classify Playlist</button>
  <p id='prediction-result'></p>
</div>

<div id="emotion-table" class="container" style='display:none'>
  <h2>Songs classification</h2>
  <table class="table">
    <thead>
      <tr>
        <th>Author</th>
        <th>Title</th>
        <th>Angry Score</th>
        <th>Happy Score</th>
        <th>Relaxed Score</th>
        <th>Sad Score</th>
      </tr>
    </thead>
    <tbody id='emotion-table-rows'>
    </tbody>
  </table>
</div>

<div id='bottom-div' class='container'>
  <div id='graph-container' class='col-sm-6'></div>
  <div id='emoj-container' class='col-sm-6'>
    <img id='emoj' style='display: none'>
  </div>
</div>

<script>
  // jQuery stuff goes here
  $(document).ready(function(){
    /**
     * Songs classification
     **/
    $('#classify-btn').click(function(ev) {
      // Clear table
      $('#classify-btn').button('loading')
      $('#emotion-table').css('display', 'block')
      $('#emotion-table-rows tr').remove()
      // Start classification of songs one by one
      for(var i = 0; i < dataset.length; i++) {
        var song = dataset[i]
        // Perform classification in background
        data = JSON.stringify({ artist: song.artist, title:song.title})
        $.ajax({
          type: "POST",
          url: "classify-song",
          contentType: 'application/json',
          dataType: 'json',
          data: JSON.stringify({
            artist: song.artist,
            title: song.title
          }, null),
          success: function(data) {
            // POST was successful - do something with the response
            // Build row
            var row = '<tr><td>' + data.artist + '</td><td>' + data.title + '</td>'
            var emo = data.emotion[0]
            var maxIdx = argMax(emo)
            for(var j = 0; j < emo.length; j++) {
              var entry = parseFloat(emo[j]).toFixed(4)
              if(j == maxIdx)
                row += '<td><b>' + entry + '</b></td>'
              else
                row += '<td>'+entry+'</td>'
            }
            row += '</tr>'
            $('#emotion-table-rows').append(row)
            $('#emotion-table-rows tr:last').css('visibility', 'visible').hide().fadeIn()

            // Reset button status
            if($('#emotion-table  tr').length == dataset.length) {
              $('#classify-btn').button('reset')
            }
         },
          error: function(data) {
            // Server error, e.g. 405, 500, error
            alert(data.responseText);
          }
        }) 
      }
    })

    /**
     * Playlist classification
     **/
    $('#classify-playlist-btn').click(function(ev) {
      predictions = buildPredictionMatrix() 

      // Send request to the server
      $.ajax({
        type: "POST",
        url: "classify-playlist",
        contentType: 'application/json',
        dataType: 'json',
        data: JSON.stringify({
          predictions: predictions,
        }, null),
        success: function(data) {
          // POST was successful - do something with the response
          prediction = data.prediction 
          outliers_count = data.outliers_count
          outliers = data.outliers

          markOutliers(outliers)
          $('#emoj').css('display', 'block')
          $('#emoj').attr('src', emotion_img[argMax(prediction)])

          // Work on transitions
          var transitions = [];
          for(var i=0; i < 4; i++) {
            transitions[i] = new Array(4)
            for(var j=0; j < 4; j++) {
              transitions[i][j] = 0
            }
          }
          
          predictions = buildPredictionMatrix()
          for(var j=0; j < predictions.length-1; j++) {
            p1 = predictions[j]
            p2 = predictions[j+1]

            x = argMax(p1)
            y = argMax(p2)
            transitions[x][y]++
          }
          buildTransitionGraph(transitions)
       },
        error: function(data) {
          // Server error, e.g. 405, 500, error
          alert(data.responseText);
        }
      }) 
    })
  })

</script>

</body>
</html>


